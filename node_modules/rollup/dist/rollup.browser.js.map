{"version":3,"file":"rollup.browser.js","sources":["../node_modules/sourcemap-codec/dist/sourcemap-codec.es.js","../node_modules/magic-string/dist/magic-string.es.mjs","../browser/path.ts","../src/utils/getOrCreate.ts","../src/ast/utils/PathTracker.ts","../src/ast/nodes/shared/Expression.ts","../src/ast/NodeInteractions.ts","../src/ast/variables/Variable.ts","../src/ast/variables/ExternalVariable.ts","../src/utils/blank.ts","../node_modules/locate-character/dist/locate-character.es.js","../src/utils/getCodeFrame.ts","../src/utils/printStringList.ts","../src/utils/relativeId.ts","../src/utils/error.ts","../src/utils/RESERVED_NAMES.ts","../src/utils/identifierHelpers.ts","../src/ExternalModule.ts","../node_modules/@rollup/pluginutils/dist/es/index.js","../src/ast/ExecutionContext.ts","../src/ast/values.ts","../node_modules/acorn-walk/dist/walk.mjs","../src/ast/nodes/NodeType.ts","../src/utils/sourceMappingURL.ts","../src/utils/pureComments.ts","../src/ast/keys.ts","../src/ast/nodes/shared/Node.ts","../src/ast/nodes/SpreadElement.ts","../src/ast/nodes/shared/MethodTypes.ts","../src/ast/nodes/shared/ObjectEntity.ts","../src/ast/nodes/shared/ObjectPrototype.ts","../src/ast/nodes/shared/ArrayPrototype.ts","../src/ast/variables/LocalVariable.ts","../src/utils/base64.ts","../src/utils/safeName.ts","../src/ast/scopes/Scope.ts","../src/ast/scopes/ChildScope.ts","../src/ast/scopes/ParameterScope.ts","../src/ast/scopes/ReturnValueScope.ts","../node_modules/is-reference/src/index.js","../src/ast/nodes/shared/knownGlobals.ts","../src/ast/variables/GlobalVariable.ts","../src/ast/nodes/Identifier.ts","../src/utils/treeshakeNode.ts","../src/utils/renderHelpers.ts","../src/ast/scopes/BlockScope.ts","../src/ast/nodes/ExpressionStatement.ts","../src/ast/nodes/BlockStatement.ts","../src/ast/nodes/RestElement.ts","../src/ast/nodes/shared/FunctionBase.ts","../src/ast/nodes/ArrowFunctionExpression.ts","../src/utils/systemJsRendering.ts","../src/ast/nodes/ObjectPattern.ts","../src/ast/variables/ArgumentsVariable.ts","../src/ast/variables/ThisVariable.ts","../src/ast/scopes/FunctionScope.ts","../src/ast/nodes/shared/FunctionNode.ts","../src/ast/nodes/BinaryExpression.ts","../src/utils/renderCallArguments.ts","../src/ast/nodes/Literal.ts","../src/ast/nodes/MemberExpression.ts","../src/ast/nodes/shared/CallExpressionBase.ts","../src/ast/scopes/CatchScope.ts","../src/ast/scopes/ClassBodyScope.ts","../src/ast/nodes/shared/MethodBase.ts","../src/ast/nodes/MethodDefinition.ts","../src/ast/nodes/shared/ObjectMember.ts","../src/ast/nodes/shared/ClassNode.ts","../src/ast/nodes/ClassDeclaration.ts","../src/ast/nodes/shared/MultiExpression.ts","../src/ast/nodes/ExportAllDeclaration.ts","../src/ast/nodes/FunctionDeclaration.ts","../src/ast/nodes/ExportDefaultDeclaration.ts","../src/ast/nodes/ExportNamedDeclaration.ts","../src/ast/scopes/TrackingScope.ts","../src/ast/nodes/IfStatement.ts","../src/ast/nodes/ImportDeclaration.ts","../src/utils/interopHelpers.ts","../src/ast/nodes/ImportExpression.ts","../src/ast/nodes/MetaProperty.ts","../src/ast/nodes/Program.ts","../src/ast/nodes/SwitchCase.ts","../src/ast/nodes/TemplateLiteral.ts","../src/ast/variables/UndefinedVariable.ts","../src/ast/variables/ExportDefaultVariable.ts","../src/ast/scopes/ModuleScope.ts","../src/ast/nodes/UnaryExpression.ts","../src/utils/reassignedExportsMember.ts","../src/ast/nodes/VariableDeclaration.ts","../src/ast/nodes/index.ts","../src/ast/nodes/ArrayExpression.ts","../src/ast/nodes/ArrayPattern.ts","../src/ast/nodes/AssignmentExpression.ts","../src/ast/nodes/AssignmentPattern.ts","../src/ast/nodes/AwaitExpression.ts","../src/ast/nodes/BreakStatement.ts","../src/ast/nodes/CallExpression.ts","../src/ast/nodes/CatchClause.ts","../src/ast/nodes/ChainExpression.ts","../src/ast/nodes/ClassBody.ts","../src/ast/nodes/ClassExpression.ts","../src/ast/nodes/ConditionalExpression.ts","../src/ast/nodes/ContinueStatement.ts","../src/ast/nodes/DoWhileStatement.ts","../src/ast/nodes/EmptyStatement.ts","../src/ast/nodes/ExportSpecifier.ts","../src/ast/nodes/ForInStatement.ts","../src/ast/nodes/ForOfStatement.ts","../src/ast/nodes/ForStatement.ts","../src/ast/nodes/FunctionExpression.ts","../src/ast/nodes/ImportDefaultSpecifier.ts","../src/ast/nodes/ImportNamespaceSpecifier.ts","../src/ast/nodes/ImportSpecifier.ts","../src/ast/nodes/LabeledStatement.ts","../src/ast/nodes/LogicalExpression.ts","../src/ast/nodes/NewExpression.ts","../src/ast/nodes/ObjectExpression.ts","../src/ast/nodes/PrivateIdentifier.ts","../src/ast/nodes/Property.ts","../src/ast/nodes/PropertyDefinition.ts","../src/ast/nodes/ReturnStatement.ts","../src/ast/nodes/SequenceExpression.ts","../src/ast/nodes/StaticBlock.ts","../src/ast/nodes/Super.ts","../src/ast/nodes/SwitchStatement.ts","../src/ast/nodes/TaggedTemplateExpression.ts","../src/ast/nodes/TemplateElement.ts","../src/ast/nodes/ThisExpression.ts","../src/ast/nodes/ThrowStatement.ts","../src/ast/nodes/TryStatement.ts","../src/ast/nodes/UnknownNode.ts","../src/ast/nodes/UpdateExpression.ts","../src/ast/nodes/VariableDeclarator.ts","../src/ast/nodes/WhileStatement.ts","../src/ast/nodes/YieldExpression.ts","../src/utils/variableNames.ts","../src/ast/variables/ExportShimVariable.ts","../src/ast/variables/NamespaceVariable.ts","../src/ast/variables/SyntheticNamedExportVariable.ts","../src/utils/buildPhase.ts","../src/utils/getId.ts","../browser/performance.ts","../browser/process.ts","../src/utils/timers.ts","../src/utils/traverseStaticDependencies.ts","../src/Module.ts","../src/utils/getOriginalLocation.ts","../src/finalisers/shared/removeJsExtension.ts","../src/finalisers/shared/getCompleteAmdId.ts","../src/finalisers/shared/getExportBlock.ts","../src/finalisers/shared/getInteropBlock.ts","../src/finalisers/shared/updateExtensionForRelativeAmdId.ts","../src/finalisers/shared/addJsExtension.ts","../src/finalisers/shared/warnOnBuiltins.ts","../src/finalisers/shared/sanitize.ts","../src/finalisers/shared/setupNamespace.ts","../src/finalisers/shared/trimEmptyImports.ts","../src/finalisers/system.ts","../src/finalisers/umd.ts","../src/finalisers/index.ts","../src/finalisers/amd.ts","../src/finalisers/cjs.ts","../src/finalisers/es.ts","../src/finalisers/iife.ts","../src/utils/collapseSourcemaps.ts","../node_modules/minimalistic-assert/index.js","../node_modules/inherits/inherits_browser.js","../node_modules/hash.js/lib/hash/utils.js","../node_modules/hash.js/lib/hash/common.js","../node_modules/hash.js/lib/hash/sha/common.js","../node_modules/hash.js/lib/hash/sha/256.js","../browser/crypto.ts","../src/utils/deconflictChunk.ts","../src/utils/escapeId.ts","../src/utils/getExportMode.ts","../src/utils/getIndentString.ts","../src/utils/getStaticDependencies.ts","../src/utils/decodedSourcemap.ts","../src/utils/outputBundle.ts","../src/utils/renderNamePattern.ts","../src/Chunk.ts","../src/utils/exportNames.ts","../src/utils/renderChunk.ts","../src/utils/addons.ts","../src/utils/chunkAssignment.ts","../src/utils/executionOrder.ts","../src/utils/generateCodeSnippets.ts","../src/Bundle.ts","../src/utils/commondir.ts","../node_modules/acorn/dist/acorn.mjs","../browser/error.ts","../browser/fs.ts","../browser/resolveId.ts","../src/utils/resolveIdViaPlugins.ts","../src/utils/pluginUtils.ts","../src/utils/PluginCache.ts","../src/utils/transform.ts","../src/ModuleLoader.ts","../src/ast/scopes/GlobalScope.ts","../src/utils/FileEmitter.ts","../src/utils/PluginContext.ts","../src/utils/PluginDriver.ts","../src/utils/Queue.ts","../src/Graph.ts","../src/utils/ensureArray.ts","../browser/hookActions.ts","../src/utils/options/options.ts","../src/utils/options/normalizeInputOptions.ts","../src/utils/sanitizeFileName.ts","../src/utils/options/normalizeOutputOptions.ts","../src/utils/url.ts","../src/rollup/rollup.ts"],"sourcesContent":["var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    var j = 0;\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n        var c = mappings.charCodeAt(i);\n        if (c === 44) { // \",\"\n            segmentify(line, segment, j);\n            j = 0;\n        }\n        else if (c === 59) { // \";\"\n            segmentify(line, segment, j);\n            j = 0;\n            decoded.push(line);\n            line = [];\n            segment[0] = 0;\n        }\n        else {\n            var integer = charToInteger[c];\n            if (integer === undefined) {\n                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n            }\n            var hasContinuationBit = integer & 32;\n            integer &= 31;\n            value += integer << shift;\n            if (hasContinuationBit) {\n                shift += 5;\n            }\n            else {\n                var shouldNegate = value & 1;\n                value >>>= 1;\n                if (shouldNegate) {\n                    value = value === 0 ? -0x80000000 : -value;\n                }\n                segment[j] += value;\n                j++;\n                value = shift = 0; // reset\n            }\n        }\n    }\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n}\nfunction segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4)\n        line.push([segment[0], segment[1], segment[2], segment[3]]);\n    else if (j === 5)\n        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n    else if (j === 1)\n        line.push([segment[0]]);\n}\nfunction encode(decoded) {\n    var sourceFileIndex = 0; // second field\n    var sourceCodeLine = 0; // third field\n    var sourceCodeColumn = 0; // fourth field\n    var nameIndex = 0; // fifth field\n    var mappings = '';\n    for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        if (i > 0)\n            mappings += ';';\n        if (line.length === 0)\n            continue;\n        var generatedCodeColumn = 0; // first field\n        var lineMappings = [];\n        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n            var segment = line_1[_i];\n            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n            generatedCodeColumn = segment[0];\n            if (segment.length > 1) {\n                segmentMappings +=\n                    encodeInteger(segment[1] - sourceFileIndex) +\n                        encodeInteger(segment[2] - sourceCodeLine) +\n                        encodeInteger(segment[3] - sourceCodeColumn);\n                sourceFileIndex = segment[1];\n                sourceCodeLine = segment[2];\n                sourceCodeColumn = segment[3];\n            }\n            if (segment.length === 5) {\n                segmentMappings += encodeInteger(segment[4] - nameIndex);\n                nameIndex = segment[4];\n            }\n            lineMappings.push(segmentMappings);\n        }\n        mappings += lineMappings.join(',');\n    }\n    return mappings;\n}\nfunction encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        var clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) {\n            clamped |= 32;\n        }\n        result += chars[clamped];\n    } while (num > 0);\n    return result;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.es.js.map\n","import { encode } from 'sourcemap-codec';\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext: { writable: true, value: null },\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = (str) => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = (str) => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: guessIndent(string) },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (typeof searchValue !== 'string' && searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null)\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null)\n\t\t\t\tthis.overwrite(\n\t\t\t\t\tmatch.index,\n\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\nexport { Bundle, SourceMap, MagicString as default };\n//# sourceMappingURL=magic-string.es.mjs.map\n","const ABSOLUTE_PATH_REGEX = /^(?:\\/|(?:[A-Za-z]:)?[\\\\|/])/;\nconst RELATIVE_PATH_REGEX = /^\\.?\\.\\//;\nconst ALL_BACKSLASHES_REGEX = /\\\\/g;\nconst ANY_SLASH_REGEX = /[/\\\\]/;\nconst EXTNAME_REGEX = /\\.[^.]+$/;\n\nexport function isAbsolute(path: string): boolean {\n\treturn ABSOLUTE_PATH_REGEX.test(path);\n}\n\nexport function isRelative(path: string): boolean {\n\treturn RELATIVE_PATH_REGEX.test(path);\n}\n\nexport function normalize(path: string): string {\n\treturn path.replace(ALL_BACKSLASHES_REGEX, '/');\n}\n\nexport function basename(path: string): string {\n\treturn path.split(ANY_SLASH_REGEX).pop() || '';\n}\n\nexport function dirname(path: string): string {\n\tconst match = /[/\\\\][^/\\\\]*$/.exec(path);\n\tif (!match) return '.';\n\n\tconst dir = path.slice(0, -match[0].length);\n\n\t// If `dir` is the empty string, we're at root.\n\treturn dir ? dir : '/';\n}\n\nexport function extname(path: string): string {\n\tconst match = EXTNAME_REGEX.exec(basename(path)!);\n\treturn match ? match[0] : '';\n}\n\nexport function relative(from: string, to: string): string {\n\tconst fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);\n\tconst toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);\n\n\tif (fromParts[0] === '.') fromParts.shift();\n\tif (toParts[0] === '.') toParts.shift();\n\n\twhile (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\twhile (toParts[0] === '..' && fromParts.length > 0) {\n\t\ttoParts.shift();\n\t\tfromParts.pop();\n\t}\n\n\twhile (fromParts.pop()) {\n\t\ttoParts.unshift('..');\n\t}\n\n\treturn toParts.join('/');\n}\n\nexport function resolve(...paths: string[]): string {\n\tconst firstPathSegment = paths.shift();\n\tif (!firstPathSegment) {\n\t\treturn '/';\n\t}\n\tlet resolvedParts = firstPathSegment.split(ANY_SLASH_REGEX);\n\n\tfor (const path of paths) {\n\t\tif (isAbsolute(path)) {\n\t\t\tresolvedParts = path.split(ANY_SLASH_REGEX);\n\t\t} else {\n\t\t\tconst parts = path.split(ANY_SLASH_REGEX);\n\n\t\t\twhile (parts[0] === '.' || parts[0] === '..') {\n\t\t\t\tconst part = parts.shift();\n\t\t\t\tif (part === '..') {\n\t\t\t\t\tresolvedParts.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolvedParts.push(...parts);\n\t\t}\n\t}\n\n\treturn resolvedParts.join('/');\n}\n","export function getOrCreate<K, V>(map: Map<K, V>, key: K, init: () => V): V {\n\tconst existing = map.get(key);\n\tif (existing) {\n\t\treturn existing;\n\t}\n\tconst value = init();\n\tmap.set(key, value);\n\treturn value;\n}\n","import { getOrCreate } from '../../utils/getOrCreate';\nimport type { Entity } from '../Entity';\n\nexport const UnknownKey = Symbol('Unknown Key');\nexport const UnknownNonAccessorKey = Symbol('Unknown Non-Accessor Key');\nexport const UnknownInteger = Symbol('Unknown Integer');\nexport type ObjectPathKey =\n\t| string\n\t| typeof UnknownKey\n\t| typeof UnknownNonAccessorKey\n\t| typeof UnknownInteger;\n\nexport type ObjectPath = ObjectPathKey[];\nexport const EMPTY_PATH: ObjectPath = [];\nexport const UNKNOWN_PATH: ObjectPath = [UnknownKey];\n// For deoptimizations, this means we are modifying an unknown property but did\n// not lose track of the object or are creating a setter/getter;\n// For assignment effects it means we do not check for setter/getter effects\n// but only if something is mutated that is included, which is relevant for\n// Object.defineProperty\nexport const UNKNOWN_NON_ACCESSOR_PATH: ObjectPath = [UnknownNonAccessorKey];\nexport const UNKNOWN_INTEGER_PATH: ObjectPath = [UnknownInteger];\n\nconst EntitiesKey = Symbol('Entities');\ninterface EntityPaths {\n\t[pathSegment: string]: EntityPaths;\n\t[EntitiesKey]: Set<Entity>;\n\t[UnknownInteger]?: EntityPaths;\n\t[UnknownKey]?: EntityPaths;\n\t[UnknownNonAccessorKey]?: EntityPaths;\n}\n\nexport class PathTracker {\n\tprivate entityPaths: EntityPaths = Object.create(null, {\n\t\t[EntitiesKey]: { value: new Set<Entity>() }\n\t});\n\n\ttrackEntityAtPathAndGetIfTracked(path: ObjectPath, entity: Entity): boolean {\n\t\tconst trackedEntities = this.getEntities(path);\n\t\tif (trackedEntities.has(entity)) return true;\n\t\ttrackedEntities.add(entity);\n\t\treturn false;\n\t}\n\n\twithTrackedEntityAtPath<T>(\n\t\tpath: ObjectPath,\n\t\tentity: Entity,\n\t\tonUntracked: () => T,\n\t\treturnIfTracked: T\n\t): T {\n\t\tconst trackedEntities = this.getEntities(path);\n\t\tif (trackedEntities.has(entity)) return returnIfTracked;\n\t\ttrackedEntities.add(entity);\n\t\tconst result = onUntracked();\n\t\ttrackedEntities.delete(entity);\n\t\treturn result;\n\t}\n\n\tprivate getEntities(path: ObjectPath): Set<Entity> {\n\t\tlet currentPaths = this.entityPaths;\n\t\tfor (const pathSegment of path) {\n\t\t\tcurrentPaths = currentPaths[pathSegment] =\n\t\t\t\tcurrentPaths[pathSegment] ||\n\t\t\t\tObject.create(null, { [EntitiesKey]: { value: new Set<Entity>() } });\n\t\t}\n\t\treturn currentPaths[EntitiesKey];\n\t}\n}\n\nexport const SHARED_RECURSION_TRACKER = new PathTracker();\n\ninterface DiscriminatedEntityPaths {\n\t[pathSegment: string]: DiscriminatedEntityPaths;\n\t[EntitiesKey]: Map<unknown, Set<Entity>>;\n\t[UnknownInteger]?: DiscriminatedEntityPaths;\n\t[UnknownKey]?: DiscriminatedEntityPaths;\n\t[UnknownNonAccessorKey]?: DiscriminatedEntityPaths;\n}\n\nexport class DiscriminatedPathTracker {\n\tprivate entityPaths: DiscriminatedEntityPaths = Object.create(null, {\n\t\t[EntitiesKey]: { value: new Map<unknown, Set<Entity>>() }\n\t});\n\n\ttrackEntityAtPathAndGetIfTracked(\n\t\tpath: ObjectPath,\n\t\tdiscriminator: unknown,\n\t\tentity: Entity\n\t): boolean {\n\t\tlet currentPaths = this.entityPaths;\n\t\tfor (const pathSegment of path) {\n\t\t\tcurrentPaths = currentPaths[pathSegment] =\n\t\t\t\tcurrentPaths[pathSegment] ||\n\t\t\t\tObject.create(null, { [EntitiesKey]: { value: new Map<unknown, Set<Entity>>() } });\n\t\t}\n\t\tconst trackedEntities = getOrCreate(currentPaths[EntitiesKey], discriminator, () => new Set());\n\t\tif (trackedEntities.has(entity)) return true;\n\t\ttrackedEntities.add(entity);\n\t\treturn false;\n\t}\n}\n","import { DeoptimizableEntity } from '../../DeoptimizableEntity';\nimport { WritableEntity } from '../../Entity';\nimport { HasEffectsContext, InclusionContext } from '../../ExecutionContext';\nimport {\n\tNodeInteraction,\n\tNodeInteractionCalled,\n\tNodeInteractionWithThisArg\n} from '../../NodeInteractions';\nimport { ObjectPath, PathTracker, UNKNOWN_PATH } from '../../utils/PathTracker';\nimport { LiteralValue } from '../Literal';\nimport SpreadElement from '../SpreadElement';\nimport { IncludeChildren } from './Node';\n\nexport const UnknownValue = Symbol('Unknown Value');\nexport const UnknownTruthyValue = Symbol('Unknown Truthy Value');\n\nexport type LiteralValueOrUnknown = LiteralValue | typeof UnknownValue | typeof UnknownTruthyValue;\n\nexport interface InclusionOptions {\n\t/**\n\t * Include the id of a declarator even if unused to ensure it is a valid statement.\n\t */\n\tasSingleStatement?: boolean;\n}\n\nexport class ExpressionEntity implements WritableEntity {\n\tincluded = false;\n\n\tdeoptimizePath(_path: ObjectPath): void {}\n\n\tdeoptimizeThisOnInteractionAtPath(\n\t\t{ thisArg }: NodeInteractionWithThisArg,\n\t\t_path: ObjectPath,\n\t\t_recursionTracker: PathTracker\n\t): void {\n\t\tthisArg!.deoptimizePath(UNKNOWN_PATH);\n\t}\n\n\t/**\n\t * If possible it returns a stringifyable literal value for this node that can be used\n\t * for inlining or comparing values.\n\t * Otherwise it should return UnknownValue.\n\t */\n\tgetLiteralValueAtPath(\n\t\t_path: ObjectPath,\n\t\t_recursionTracker: PathTracker,\n\t\t_origin: DeoptimizableEntity\n\t): LiteralValueOrUnknown {\n\t\treturn UnknownValue;\n\t}\n\n\tgetReturnExpressionWhenCalledAtPath(\n\t\t_path: ObjectPath,\n\t\t_interaction: NodeInteractionCalled,\n\t\t_recursionTracker: PathTracker,\n\t\t_origin: DeoptimizableEntity\n\t): ExpressionEntity {\n\t\treturn UNKNOWN_EXPRESSION;\n\t}\n\n\thasEffectsOnInteractionAtPath(\n\t\t_path: ObjectPath,\n\t\t_interaction: NodeInteraction,\n\t\t_context: HasEffectsContext\n\t): boolean {\n\t\treturn true;\n\t}\n\n\tinclude(\n\t\t_context: InclusionContext,\n\t\t_includeChildrenRecursively: IncludeChildren,\n\t\t_options?: InclusionOptions\n\t): void {\n\t\tthis.included = true;\n\t}\n\n\tincludeCallArguments(\n\t\tcontext: InclusionContext,\n\t\targs: readonly (ExpressionEntity | SpreadElement)[]\n\t): void {\n\t\tfor (const arg of args) {\n\t\t\targ.include(context, false);\n\t\t}\n\t}\n\n\tshouldBeIncluded(_context: InclusionContext): boolean {\n\t\treturn true;\n\t}\n}\n\nexport const UNKNOWN_EXPRESSION: ExpressionEntity =\n\tnew (class UnknownExpression extends ExpressionEntity {})();\n","import SpreadElement from './nodes/SpreadElement';\nimport { ExpressionEntity, UNKNOWN_EXPRESSION } from './nodes/shared/Expression';\n\nexport const INTERACTION_ACCESSED = 0;\nexport const INTERACTION_ASSIGNED = 1;\nexport const INTERACTION_CALLED = 2;\n\nexport interface NodeInteractionAccessed {\n\tthisArg: ExpressionEntity | null;\n\ttype: typeof INTERACTION_ACCESSED;\n}\n\nexport const NODE_INTERACTION_UNKNOWN_ACCESS: NodeInteractionAccessed = {\n\tthisArg: null,\n\ttype: INTERACTION_ACCESSED\n};\n\nexport interface NodeInteractionAssigned {\n\targs: readonly [ExpressionEntity];\n\tthisArg: ExpressionEntity | null;\n\ttype: typeof INTERACTION_ASSIGNED;\n}\n\nexport const UNKNOWN_ARG = [UNKNOWN_EXPRESSION] as const;\n\nexport const NODE_INTERACTION_UNKNOWN_ASSIGNMENT: NodeInteractionAssigned = {\n\targs: UNKNOWN_ARG,\n\tthisArg: null,\n\ttype: INTERACTION_ASSIGNED\n};\n\nexport interface NodeInteractionCalled {\n\targs: readonly (ExpressionEntity | SpreadElement)[];\n\tthisArg: ExpressionEntity | null;\n\ttype: typeof INTERACTION_CALLED;\n\twithNew: boolean;\n}\n\nexport const NO_ARGS = [];\n\n// While this is technically a call without arguments, we can compare against\n// this reference in places where precise values or thisArg would make a\n// difference\nexport const NODE_INTERACTION_UNKNOWN_CALL: NodeInteractionCalled = {\n\targs: NO_ARGS,\n\tthisArg: null,\n\ttype: INTERACTION_CALLED,\n\twithNew: false\n};\n\nexport type NodeInteraction =\n\t| NodeInteractionAccessed\n\t| NodeInteractionAssigned\n\t| NodeInteractionCalled;\n\nexport type NodeInteractionWithThisArg = NodeInteraction & { thisArg: ExpressionEntity };\n","import type ExternalModule from '../../ExternalModule';\nimport type Module from '../../Module';\nimport type { HasEffectsContext } from '../ExecutionContext';\nimport { INTERACTION_ACCESSED, NodeInteraction } from '../NodeInteractions';\nimport type Identifier from '../nodes/Identifier';\nimport { ExpressionEntity } from '../nodes/shared/Expression';\nimport type { ObjectPath } from '../utils/PathTracker';\n\nexport default class Variable extends ExpressionEntity {\n\talwaysRendered = false;\n\tinitReached = false;\n\tisId = false;\n\t// both NamespaceVariable and ExternalVariable can be namespaces\n\tdeclare isNamespace?: boolean;\n\tisReassigned = false;\n\tkind: string | null = null;\n\tdeclare module?: Module | ExternalModule;\n\trenderBaseName: string | null = null;\n\trenderName: string | null = null;\n\n\tconstructor(public name: string) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Binds identifiers that reference this variable to this variable.\n\t * Necessary to be able to change variable names.\n\t */\n\taddReference(_identifier: Identifier): void {}\n\n\tgetBaseVariableName(): string {\n\t\treturn this.renderBaseName || this.renderName || this.name;\n\t}\n\n\tgetName(getPropertyAccess: (name: string) => string): string {\n\t\tconst name = this.renderName || this.name;\n\t\treturn this.renderBaseName ? `${this.renderBaseName}${getPropertyAccess(name)}` : name;\n\t}\n\n\thasEffectsOnInteractionAtPath(\n\t\tpath: ObjectPath,\n\t\t{ type }: NodeInteraction,\n\t\t_context: HasEffectsContext\n\t): boolean {\n\t\treturn type !== INTERACTION_ACCESSED || path.length > 0;\n\t}\n\n\t/**\n\t * Marks this variable as being part of the bundle, which is usually the case when one of\n\t * its identifiers becomes part of the bundle. Returns true if it has not been included\n\t * previously.\n\t * Once a variable is included, it should take care all its declarations are included.\n\t */\n\tinclude(): void {\n\t\tthis.included = true;\n\t}\n\n\tmarkCalledFromTryStatement(): void {}\n\n\tsetRenderNames(baseName: string | null, name: string | null): void {\n\t\tthis.renderBaseName = baseName;\n\t\tthis.renderName = name;\n\t}\n}\n","import type ExternalModule from '../../ExternalModule';\nimport { INTERACTION_ACCESSED, NodeInteraction } from '../NodeInteractions';\nimport type Identifier from '../nodes/Identifier';\nimport type { ObjectPath } from '../utils/PathTracker';\nimport Variable from './Variable';\n\nexport default class ExternalVariable extends Variable {\n\tisNamespace: boolean;\n\tmodule: ExternalModule;\n\treferenced = false;\n\n\tconstructor(module: ExternalModule, name: string) {\n\t\tsuper(name);\n\t\tthis.module = module;\n\t\tthis.isNamespace = name === '*';\n\t}\n\n\taddReference(identifier: Identifier): void {\n\t\tthis.referenced = true;\n\t\tif (this.name === 'default' || this.name === '*') {\n\t\t\tthis.module.suggestName(identifier.name);\n\t\t}\n\t}\n\n\thasEffectsOnInteractionAtPath(path: ObjectPath, { type }: NodeInteraction): boolean {\n\t\treturn type !== INTERACTION_ACCESSED || path.length > (this.isNamespace ? 1 : 0);\n\t}\n\n\tinclude(): void {\n\t\tif (!this.included) {\n\t\t\tthis.included = true;\n\t\t\tthis.module.used = true;\n\t\t}\n\t}\n}\n","export const BLANK: Record<string, unknown> = Object.freeze(Object.create(null));\nexport const EMPTY_OBJECT = Object.freeze({});\nexport const EMPTY_ARRAY = Object.freeze([]);\n","function getLocator(source, options) {\n    if (options === void 0) { options = {}; }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    ;\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\n\nexport { getLocator, locate };","function spaces(i: number): string {\n\tlet result = '';\n\twhile (i--) result += ' ';\n\treturn result;\n}\n\nfunction tabsToSpaces(str: string): string {\n\treturn str.replace(/^\\t+/, match => match.split('\\t').join('  '));\n}\n\nexport default function getCodeFrame(source: string, line: number, column: number): string {\n\tlet lines = source.split('\\n');\n\n\tconst frameStart = Math.max(0, line - 3);\n\tlet frameEnd = Math.min(line + 2, lines.length);\n\n\tlines = lines.slice(frameStart, frameEnd);\n\twhile (!/\\S/.test(lines[lines.length - 1])) {\n\t\tlines.pop();\n\t\tframeEnd -= 1;\n\t}\n\n\tconst digits = String(frameEnd).length;\n\n\treturn lines\n\t\t.map((str, i) => {\n\t\t\tconst isErrorLine = frameStart + i + 1 === line;\n\n\t\t\tlet lineNum = String(i + frameStart + 1);\n\t\t\twhile (lineNum.length < digits) lineNum = ` ${lineNum}`;\n\n\t\t\tif (isErrorLine) {\n\t\t\t\tconst indicator = spaces(digits + 2 + tabsToSpaces(str.slice(0, column)).length) + '^';\n\t\t\t\treturn `${lineNum}: ${tabsToSpaces(str)}\\n${indicator}`;\n\t\t\t}\n\n\t\t\treturn `${lineNum}: ${tabsToSpaces(str)}`;\n\t\t})\n\t\t.join('\\n');\n}\n","export function printQuotedStringList(\n\tlist: readonly string[],\n\tverbs?: readonly [string, string]\n): string {\n\tconst isSingleItem = list.length <= 1;\n\tconst quotedList = list.map(item => `\"${item}\"`);\n\tlet output = isSingleItem\n\t\t? quotedList[0]\n\t\t: `${quotedList.slice(0, -1).join(', ')} and ${quotedList.slice(-1)[0]}`;\n\tif (verbs) {\n\t\toutput += ` ${isSingleItem ? verbs[0] : verbs[1]}`;\n\t}\n\treturn output;\n}\n","import { relative } from '../../browser/path';\nimport { basename, dirname, extname, isAbsolute, normalize, resolve } from './path';\n\nexport function getAliasName(id: string): string {\n\tconst base = basename(id);\n\treturn base.substring(0, base.length - extname(id).length);\n}\n\nexport default function relativeId(id: string): string {\n\tif (!isAbsolute(id)) return id;\n\treturn relative(resolve(), id);\n}\n\nexport function isPathFragment(name: string): boolean {\n\t// starting with \"/\", \"./\", \"../\", \"C:/\"\n\treturn (\n\t\tname[0] === '/' || (name[0] === '.' && (name[1] === '/' || name[1] === '.')) || isAbsolute(name)\n\t);\n}\n\nconst UPPER_DIR_REGEX = /^(\\.\\.\\/)*\\.\\.$/;\n\nexport function getImportPath(\n\timporterId: string,\n\ttargetPath: string,\n\tstripJsExtension: boolean,\n\tensureFileName: boolean\n): string {\n\tlet relativePath = normalize(relative(dirname(importerId), targetPath));\n\tif (stripJsExtension && relativePath.endsWith('.js')) {\n\t\trelativePath = relativePath.slice(0, -3);\n\t}\n\tif (ensureFileName) {\n\t\tif (relativePath === '') return '../' + basename(targetPath);\n\t\tif (UPPER_DIR_REGEX.test(relativePath)) {\n\t\t\treturn relativePath\n\t\t\t\t.split('/')\n\t\t\t\t.concat(['..', basename(targetPath)])\n\t\t\t\t.join('/');\n\t\t}\n\t}\n\treturn !relativePath ? '.' : relativePath.startsWith('..') ? relativePath : './' + relativePath;\n}\n","import { locate } from 'locate-character';\nimport type Module from '../Module';\nimport type {\n\tNormalizedInputOptions,\n\tRollupError,\n\tRollupLogProps,\n\tRollupWarning,\n\tWarningHandler\n} from '../rollup/types';\nimport getCodeFrame from './getCodeFrame';\nimport { printQuotedStringList } from './printStringList';\nimport relativeId from './relativeId';\n\nexport function error(base: Error | RollupError): never {\n\tif (!(base instanceof Error)) base = Object.assign(new Error(base.message), base);\n\tthrow base;\n}\n\nexport function augmentCodeLocation(\n\tprops: RollupLogProps,\n\tpos: number | { column: number; line: number },\n\tsource: string,\n\tid: string\n): void {\n\tif (typeof pos === 'object') {\n\t\tconst { line, column } = pos;\n\t\tprops.loc = { column, file: id, line };\n\t} else {\n\t\tprops.pos = pos;\n\t\tconst { line, column } = locate(source, pos, { offsetLine: 1 });\n\t\tprops.loc = { column, file: id, line };\n\t}\n\n\tif (props.frame === undefined) {\n\t\tconst { line, column } = props.loc;\n\t\tprops.frame = getCodeFrame(source, line, column);\n\t}\n}\n\nexport const enum Errors {\n\tALREADY_CLOSED = 'ALREADY_CLOSED',\n\tASSET_NOT_FINALISED = 'ASSET_NOT_FINALISED',\n\tASSET_NOT_FOUND = 'ASSET_NOT_FOUND',\n\tASSET_SOURCE_ALREADY_SET = 'ASSET_SOURCE_ALREADY_SET',\n\tASSET_SOURCE_MISSING = 'ASSET_SOURCE_MISSING',\n\tBAD_LOADER = 'BAD_LOADER',\n\tCANNOT_EMIT_FROM_OPTIONS_HOOK = 'CANNOT_EMIT_FROM_OPTIONS_HOOK',\n\tCHUNK_NOT_GENERATED = 'CHUNK_NOT_GENERATED',\n\tCHUNK_INVALID = 'CHUNK_INVALID',\n\tCIRCULAR_REEXPORT = 'CIRCULAR_REEXPORT',\n\tCYCLIC_CROSS_CHUNK_REEXPORT = 'CYCLIC_CROSS_CHUNK_REEXPORT',\n\tDEPRECATED_FEATURE = 'DEPRECATED_FEATURE',\n\tEXTERNAL_SYNTHETIC_EXPORTS = 'EXTERNAL_SYNTHETIC_EXPORTS',\n\tFILE_NAME_CONFLICT = 'FILE_NAME_CONFLICT',\n\tFILE_NOT_FOUND = 'FILE_NOT_FOUND',\n\tINPUT_HOOK_IN_OUTPUT_PLUGIN = 'INPUT_HOOK_IN_OUTPUT_PLUGIN',\n\tINVALID_CHUNK = 'INVALID_CHUNK',\n\tINVALID_EXPORT_OPTION = 'INVALID_EXPORT_OPTION',\n\tINVALID_EXTERNAL_ID = 'INVALID_EXTERNAL_ID',\n\tINVALID_OPTION = 'INVALID_OPTION',\n\tINVALID_PLUGIN_HOOK = 'INVALID_PLUGIN_HOOK',\n\tINVALID_ROLLUP_PHASE = 'INVALID_ROLLUP_PHASE',\n\tMISSING_EXPORT = 'MISSING_EXPORT',\n\tMISSING_IMPLICIT_DEPENDANT = 'MISSING_IMPLICIT_DEPENDANT',\n\tMIXED_EXPORTS = 'MIXED_EXPORTS',\n\tNAMESPACE_CONFLICT = 'NAMESPACE_CONFLICT',\n\tAMBIGUOUS_EXTERNAL_NAMESPACES = 'AMBIGUOUS_EXTERNAL_NAMESPACES',\n\tNO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE = 'NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE',\n\tPLUGIN_ERROR = 'PLUGIN_ERROR',\n\tPREFER_NAMED_EXPORTS = 'PREFER_NAMED_EXPORTS',\n\tSYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT = 'SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT',\n\tUNEXPECTED_NAMED_IMPORT = 'UNEXPECTED_NAMED_IMPORT',\n\tUNRESOLVED_ENTRY = 'UNRESOLVED_ENTRY',\n\tUNRESOLVED_IMPORT = 'UNRESOLVED_IMPORT',\n\tVALIDATION_ERROR = 'VALIDATION_ERROR'\n}\n\nexport function errAssetNotFinalisedForFileName(name: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.ASSET_NOT_FINALISED,\n\t\tmessage: `Plugin error - Unable to get file name for asset \"${name}\". Ensure that the source is set and that generate is called first.`\n\t};\n}\n\nexport function errCannotEmitFromOptionsHook(): RollupLogProps {\n\treturn {\n\t\tcode: Errors.CANNOT_EMIT_FROM_OPTIONS_HOOK,\n\t\tmessage: `Cannot emit files or set asset sources in the \"outputOptions\" hook, use the \"renderStart\" hook instead.`\n\t};\n}\n\nexport function errChunkNotGeneratedForFileName(name: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.CHUNK_NOT_GENERATED,\n\t\tmessage: `Plugin error - Unable to get file name for chunk \"${name}\". Ensure that generate is called first.`\n\t};\n}\n\nexport function errChunkInvalid(\n\t{ fileName, code }: { code: string; fileName: string },\n\texception: { loc: { column: number; line: number }; message: string }\n): RollupLogProps {\n\tconst errorProps = {\n\t\tcode: Errors.CHUNK_INVALID,\n\t\tmessage: `Chunk \"${fileName}\" is not valid JavaScript: ${exception.message}.`\n\t};\n\taugmentCodeLocation(errorProps, exception.loc, code, fileName);\n\treturn errorProps;\n}\n\nexport function errCircularReexport(exportName: string, importedModule: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.CIRCULAR_REEXPORT,\n\t\tid: importedModule,\n\t\tmessage: `\"${exportName}\" cannot be exported from ${relativeId(\n\t\t\timportedModule\n\t\t)} as it is a reexport that references itself.`\n\t};\n}\n\nexport function errCyclicCrossChunkReexport(\n\texportName: string,\n\texporter: string,\n\treexporter: string,\n\timporter: string\n): RollupWarning {\n\treturn {\n\t\tcode: Errors.CYCLIC_CROSS_CHUNK_REEXPORT,\n\t\texporter,\n\t\timporter,\n\t\tmessage: `Export \"${exportName}\" of module ${relativeId(\n\t\t\texporter\n\t\t)} was reexported through module ${relativeId(\n\t\t\treexporter\n\t\t)} while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.\\nEither change the import in ${relativeId(\n\t\t\timporter\n\t\t)} to point directly to the exporting module or do not use \"preserveModules\" to ensure these modules end up in the same chunk.`,\n\t\treexporter\n\t};\n}\n\nexport function errAssetReferenceIdNotFoundForSetSource(assetReferenceId: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.ASSET_NOT_FOUND,\n\t\tmessage: `Plugin error - Unable to set the source for unknown asset \"${assetReferenceId}\".`\n\t};\n}\n\nexport function errAssetSourceAlreadySet(name: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.ASSET_SOURCE_ALREADY_SET,\n\t\tmessage: `Unable to set the source for asset \"${name}\", source already set.`\n\t};\n}\n\nexport function errNoAssetSourceSet(assetName: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.ASSET_SOURCE_MISSING,\n\t\tmessage: `Plugin error creating asset \"${assetName}\" - no asset source set.`\n\t};\n}\n\nexport function errBadLoader(id: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.BAD_LOADER,\n\t\tmessage: `Error loading ${relativeId(\n\t\t\tid\n\t\t)}: plugin load hook should return a string, a { code, map } object, or nothing/null`\n\t};\n}\n\nexport function errDeprecation(deprecation: string | RollupWarning): RollupLogProps {\n\treturn {\n\t\tcode: Errors.DEPRECATED_FEATURE,\n\t\t...(typeof deprecation === 'string' ? { message: deprecation } : deprecation)\n\t};\n}\n\nexport function errFileReferenceIdNotFoundForFilename(assetReferenceId: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.FILE_NOT_FOUND,\n\t\tmessage: `Plugin error - Unable to get file name for unknown file \"${assetReferenceId}\".`\n\t};\n}\n\nexport function errFileNameConflict(fileName: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.FILE_NAME_CONFLICT,\n\t\tmessage: `The emitted file \"${fileName}\" overwrites a previously emitted file of the same name.`\n\t};\n}\n\nexport function errInputHookInOutputPlugin(pluginName: string, hookName: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.INPUT_HOOK_IN_OUTPUT_PLUGIN,\n\t\tmessage: `The \"${hookName}\" hook used by the output plugin ${pluginName} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`\n\t};\n}\n\nexport function errCannotAssignModuleToChunk(\n\tmoduleId: string,\n\tassignToAlias: string,\n\tcurrentAlias: string\n): RollupLogProps {\n\treturn {\n\t\tcode: Errors.INVALID_CHUNK,\n\t\tmessage: `Cannot assign ${relativeId(\n\t\t\tmoduleId\n\t\t)} to the \"${assignToAlias}\" chunk as it is already in the \"${currentAlias}\" chunk.`\n\t};\n}\n\nexport function errInvalidExportOptionValue(optionValue: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.INVALID_EXPORT_OPTION,\n\t\tmessage: `\"output.exports\" must be \"default\", \"named\", \"none\", \"auto\", or left unspecified (defaults to \"auto\"), received \"${optionValue}\"`,\n\t\turl: `https://rollupjs.org/guide/en/#outputexports`\n\t};\n}\n\nexport function errIncompatibleExportOptionValue(\n\toptionValue: string,\n\tkeys: readonly string[],\n\tentryModule: string\n): RollupLogProps {\n\treturn {\n\t\tcode: 'INVALID_EXPORT_OPTION',\n\t\tmessage: `\"${optionValue}\" was specified for \"output.exports\", but entry module \"${relativeId(\n\t\t\tentryModule\n\t\t)}\" has the following exports: ${keys.join(', ')}`\n\t};\n}\n\nexport function errInternalIdCannotBeExternal(source: string, importer: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.INVALID_EXTERNAL_ID,\n\t\tmessage: `'${source}' is imported as an external by ${relativeId(\n\t\t\timporter\n\t\t)}, but is already an existing non-external module id.`\n\t};\n}\n\nexport function errInvalidOption(\n\toption: string,\n\turlHash: string,\n\texplanation: string,\n\tvalue?: string | boolean | null\n): RollupLogProps {\n\treturn {\n\t\tcode: Errors.INVALID_OPTION,\n\t\tmessage: `Invalid value ${\n\t\t\tvalue !== undefined ? `${JSON.stringify(value)} ` : ''\n\t\t}for option \"${option}\" - ${explanation}.`,\n\t\turl: `https://rollupjs.org/guide/en/#${urlHash}`\n\t};\n}\n\nexport function errInvalidAddonPluginHook(hook: string, plugin: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.INVALID_PLUGIN_HOOK,\n\t\thook,\n\t\tmessage: `Error running plugin hook ${hook} for plugin ${plugin}, expected a string, a function hook or an object with a \"handler\" string or function.`,\n\t\tplugin\n\t};\n}\n\nexport function errInvalidFunctionPluginHook(hook: string, plugin: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.INVALID_PLUGIN_HOOK,\n\t\thook,\n\t\tmessage: `Error running plugin hook ${hook} for plugin ${plugin}, expected a function hook or an object with a \"handler\" function.`,\n\t\tplugin\n\t};\n}\n\nexport function errInvalidRollupPhaseForAddWatchFile(): RollupLogProps {\n\treturn {\n\t\tcode: Errors.INVALID_ROLLUP_PHASE,\n\t\tmessage: `Cannot call addWatchFile after the build has finished.`\n\t};\n}\n\nexport function errInvalidRollupPhaseForChunkEmission(): RollupLogProps {\n\treturn {\n\t\tcode: Errors.INVALID_ROLLUP_PHASE,\n\t\tmessage: `Cannot emit chunks after module loading has finished.`\n\t};\n}\n\nexport function errMissingExport(\n\texportName: string,\n\timportingModule: string,\n\timportedModule: string\n): RollupLogProps {\n\treturn {\n\t\tcode: Errors.MISSING_EXPORT,\n\t\tmessage: `'${exportName}' is not exported by ${relativeId(\n\t\t\timportedModule\n\t\t)}, imported by ${relativeId(importingModule)}`,\n\t\turl: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`\n\t};\n}\n\nexport function errImplicitDependantCannotBeExternal(\n\tunresolvedId: string,\n\timplicitlyLoadedBefore: string\n): RollupLogProps {\n\treturn {\n\t\tcode: Errors.MISSING_IMPLICIT_DEPENDANT,\n\t\tmessage: `Module \"${relativeId(\n\t\t\tunresolvedId\n\t\t)}\" that should be implicitly loaded before \"${relativeId(\n\t\t\timplicitlyLoadedBefore\n\t\t)}\" cannot be external.`\n\t};\n}\n\nexport function errUnresolvedImplicitDependant(\n\tunresolvedId: string,\n\timplicitlyLoadedBefore: string\n): RollupLogProps {\n\treturn {\n\t\tcode: Errors.MISSING_IMPLICIT_DEPENDANT,\n\t\tmessage: `Module \"${relativeId(\n\t\t\tunresolvedId\n\t\t)}\" that should be implicitly loaded before \"${relativeId(\n\t\t\timplicitlyLoadedBefore\n\t\t)}\" could not be resolved.`\n\t};\n}\n\nexport function errImplicitDependantIsNotIncluded(module: Module): RollupLogProps {\n\tconst implicitDependencies = Array.from(module.implicitlyLoadedBefore, dependency =>\n\t\trelativeId(dependency.id)\n\t).sort();\n\treturn {\n\t\tcode: Errors.MISSING_IMPLICIT_DEPENDANT,\n\t\tmessage: `Module \"${relativeId(\n\t\t\tmodule.id\n\t\t)}\" that should be implicitly loaded before ${printQuotedStringList(\n\t\t\timplicitDependencies\n\t\t)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`\n\t};\n}\n\nexport function errMixedExport(facadeModuleId: string, name?: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.MIXED_EXPORTS,\n\t\tid: facadeModuleId,\n\t\tmessage: `Entry module \"${relativeId(\n\t\t\tfacadeModuleId\n\t\t)}\" is using named and default exports together. Consumers of your bundle will have to use \\`${\n\t\t\tname || 'chunk'\n\t\t}[\"default\"]\\` to access the default export, which may not be what you want. Use \\`output.exports: \"named\"\\` to disable this warning`,\n\t\turl: `https://rollupjs.org/guide/en/#outputexports`\n\t};\n}\n\nexport function errNamespaceConflict(\n\tname: string,\n\treexportingModuleId: string,\n\tsources: string[]\n): RollupWarning {\n\treturn {\n\t\tcode: Errors.NAMESPACE_CONFLICT,\n\t\tmessage: `Conflicting namespaces: \"${relativeId(\n\t\t\treexportingModuleId\n\t\t)}\" re-exports \"${name}\" from one of the modules ${printQuotedStringList(\n\t\t\tsources.map(moduleId => relativeId(moduleId))\n\t\t)} (will be ignored)`,\n\t\tname,\n\t\treexporter: reexportingModuleId,\n\t\tsources\n\t};\n}\n\nexport function errAmbiguousExternalNamespaces(\n\tname: string,\n\treexportingModule: string,\n\tusedModule: string,\n\tsources: string[]\n): RollupWarning {\n\treturn {\n\t\tcode: Errors.AMBIGUOUS_EXTERNAL_NAMESPACES,\n\t\tmessage: `Ambiguous external namespace resolution: \"${relativeId(\n\t\t\treexportingModule\n\t\t)}\" re-exports \"${name}\" from one of the external modules ${printQuotedStringList(\n\t\t\tsources.map(module => relativeId(module))\n\t\t)}, guessing \"${relativeId(usedModule)}\".`,\n\t\tname,\n\t\treexporter: reexportingModule,\n\t\tsources\n\t};\n}\n\nexport function errNoTransformMapOrAstWithoutCode(pluginName: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE,\n\t\tmessage:\n\t\t\t`The plugin \"${pluginName}\" returned a \"map\" or \"ast\" without returning ` +\n\t\t\t'a \"code\". This will be ignored.'\n\t};\n}\n\nexport function errPreferNamedExports(facadeModuleId: string): RollupLogProps {\n\tconst file = relativeId(facadeModuleId);\n\treturn {\n\t\tcode: Errors.PREFER_NAMED_EXPORTS,\n\t\tid: facadeModuleId,\n\t\tmessage: `Entry module \"${file}\" is implicitly using \"default\" export mode, which means for CommonJS output that its default export is assigned to \"module.exports\". For many tools, such CommonJS output will not be interchangeable with the original ES module. If this is intended, explicitly set \"output.exports\" to either \"auto\" or \"default\", otherwise you might want to consider changing the signature of \"${file}\" to use named exports only.`,\n\t\turl: `https://rollupjs.org/guide/en/#outputexports`\n\t};\n}\n\nexport function errSyntheticNamedExportsNeedNamespaceExport(\n\tid: string,\n\tsyntheticNamedExportsOption: boolean | string\n): RollupLogProps {\n\treturn {\n\t\tcode: Errors.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT,\n\t\tid,\n\t\tmessage: `Module \"${relativeId(\n\t\t\tid\n\t\t)}\" that is marked with 'syntheticNamedExports: ${JSON.stringify(\n\t\t\tsyntheticNamedExportsOption\n\t\t)}' needs ${\n\t\t\ttypeof syntheticNamedExportsOption === 'string' && syntheticNamedExportsOption !== 'default'\n\t\t\t\t? `an explicit export named \"${syntheticNamedExportsOption}\"`\n\t\t\t\t: 'a default export'\n\t\t} that does not reexport an unresolved named export of the same module.`\n\t};\n}\n\nexport function errUnexpectedNamedImport(\n\tid: string,\n\timported: string,\n\tisReexport: boolean\n): RollupLogProps {\n\tconst importType = isReexport ? 'reexport' : 'import';\n\treturn {\n\t\tcode: Errors.UNEXPECTED_NAMED_IMPORT,\n\t\tid,\n\t\tmessage: `The named export \"${imported}\" was ${importType}ed from the external module ${relativeId(\n\t\t\tid\n\t\t)} even though its interop type is \"defaultOnly\". Either remove or change this ${importType} or change the value of the \"output.interop\" option.`,\n\t\turl: 'https://rollupjs.org/guide/en/#outputinterop'\n\t};\n}\n\nexport function errUnexpectedNamespaceReexport(id: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.UNEXPECTED_NAMED_IMPORT,\n\t\tid,\n\t\tmessage: `There was a namespace \"*\" reexport from the external module ${relativeId(\n\t\t\tid\n\t\t)} even though its interop type is \"defaultOnly\". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the \"output.interop\" option.`,\n\t\turl: 'https://rollupjs.org/guide/en/#outputinterop'\n\t};\n}\n\nexport function errEntryCannotBeExternal(unresolvedId: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.UNRESOLVED_ENTRY,\n\t\tmessage: `Entry module cannot be external (${relativeId(unresolvedId)}).`\n\t};\n}\n\nexport function errUnresolvedEntry(unresolvedId: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.UNRESOLVED_ENTRY,\n\t\tmessage: `Could not resolve entry module (${relativeId(unresolvedId)}).`\n\t};\n}\n\nexport function errUnresolvedImport(source: string, importer: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.UNRESOLVED_IMPORT,\n\t\tmessage: `Could not resolve '${source}' from ${relativeId(importer)}`\n\t};\n}\n\nexport function errUnresolvedImportTreatedAsExternal(\n\tsource: string,\n\timporter: string\n): RollupWarning {\n\treturn {\n\t\tcode: Errors.UNRESOLVED_IMPORT,\n\t\timporter: relativeId(importer),\n\t\tmessage: `'${source}' is imported by ${relativeId(\n\t\t\timporter\n\t\t)}, but could not be resolved – treating it as an external dependency`,\n\t\tsource,\n\t\turl: 'https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency'\n\t};\n}\n\nexport function errExternalSyntheticExports(source: string, importer: string): RollupWarning {\n\treturn {\n\t\tcode: Errors.EXTERNAL_SYNTHETIC_EXPORTS,\n\t\timporter: relativeId(importer),\n\t\tmessage: `External '${source}' can not have 'syntheticNamedExports' enabled.`,\n\t\tsource\n\t};\n}\n\nexport function errFailedValidation(message: string): RollupLogProps {\n\treturn {\n\t\tcode: Errors.VALIDATION_ERROR,\n\t\tmessage\n\t};\n}\n\nexport function errAlreadyClosed(): RollupLogProps {\n\treturn {\n\t\tcode: Errors.ALREADY_CLOSED,\n\t\tmessage: 'Bundle is already closed, no more calls to \"generate\" or \"write\" are allowed.'\n\t};\n}\n\nexport function warnDeprecation(\n\tdeprecation: string | RollupWarning,\n\tactiveDeprecation: boolean,\n\toptions: NormalizedInputOptions\n): void {\n\twarnDeprecationWithOptions(\n\t\tdeprecation,\n\t\tactiveDeprecation,\n\t\toptions.onwarn,\n\t\toptions.strictDeprecations\n\t);\n}\n\nexport function warnDeprecationWithOptions(\n\tdeprecation: string | RollupWarning,\n\tactiveDeprecation: boolean,\n\twarn: WarningHandler,\n\tstrictDeprecations: boolean\n): void {\n\tif (activeDeprecation || strictDeprecations) {\n\t\tconst warning = errDeprecation(deprecation);\n\t\tif (strictDeprecations) {\n\t\t\treturn error(warning);\n\t\t}\n\t\twarn(warning);\n\t}\n}\n","const RESERVED_NAMES: ReadonlySet<string> = new Set([\n\t'await',\n\t'break',\n\t'case',\n\t'catch',\n\t'class',\n\t'const',\n\t'continue',\n\t'debugger',\n\t'default',\n\t'delete',\n\t'do',\n\t'else',\n\t'enum',\n\t'eval',\n\t'export',\n\t'extends',\n\t'false',\n\t'finally',\n\t'for',\n\t'function',\n\t'if',\n\t'implements',\n\t'import',\n\t'in',\n\t'instanceof',\n\t'interface',\n\t'let',\n\t'NaN',\n\t'new',\n\t'null',\n\t'package',\n\t'private',\n\t'protected',\n\t'public',\n\t'return',\n\t'static',\n\t'super',\n\t'switch',\n\t'this',\n\t'throw',\n\t'true',\n\t'try',\n\t'typeof',\n\t'undefined',\n\t'var',\n\t'void',\n\t'while',\n\t'with',\n\t'yield'\n]);\n\nexport default RESERVED_NAMES;\n","import RESERVED_NAMES from './RESERVED_NAMES';\n\nconst illegalCharacters = /[^$_a-zA-Z0-9]/g;\n\nconst startsWithDigit = (str: string): boolean => /\\d/.test(str[0]);\n\nconst needsEscape = (str: string) =>\n\tstartsWithDigit(str) || RESERVED_NAMES.has(str) || str === 'arguments';\n\nexport function isLegal(str: string): boolean {\n\tif (needsEscape(str)) {\n\t\treturn false;\n\t}\n\treturn !illegalCharacters.test(str);\n}\n\nexport function makeLegal(str: string): string {\n\tstr = str.replace(/-(\\w)/g, (_, letter) => letter.toUpperCase()).replace(illegalCharacters, '_');\n\n\tif (needsEscape(str)) str = `_${str}`;\n\n\treturn str || '_';\n}\n","import ExternalVariable from './ast/variables/ExternalVariable';\nimport type {\n\tCustomPluginOptions,\n\tModuleInfo,\n\tNormalizedInputOptions,\n\tNormalizedOutputOptions\n} from './rollup/types';\nimport { EMPTY_ARRAY } from './utils/blank';\nimport { warnDeprecation } from './utils/error';\nimport { makeLegal } from './utils/identifierHelpers';\nimport { normalize, relative } from './utils/path';\nimport { printQuotedStringList } from './utils/printStringList';\nimport relativeId from './utils/relativeId';\n\nexport default class ExternalModule {\n\treadonly declarations = new Map<string, ExternalVariable>();\n\tdefaultVariableName = '';\n\treadonly dynamicImporters: string[] = [];\n\texecIndex = Infinity;\n\treadonly exportedVariables = new Map<ExternalVariable, string>();\n\treadonly importers: string[] = [];\n\treadonly info: ModuleInfo;\n\tmostCommonSuggestion = 0;\n\treadonly nameSuggestions = new Map<string, number>();\n\tnamespaceVariableName = '';\n\treexported = false;\n\trenderPath: string = undefined as never;\n\tsuggestedVariableName: string;\n\tused = false;\n\tvariableName = '';\n\n\tconstructor(\n\t\tprivate readonly options: NormalizedInputOptions,\n\t\tpublic readonly id: string,\n\t\tmoduleSideEffects: boolean | 'no-treeshake',\n\t\tmeta: CustomPluginOptions,\n\t\tpublic readonly renormalizeRenderPath: boolean\n\t) {\n\t\tthis.suggestedVariableName = makeLegal(id.split(/[\\\\/]/).pop()!);\n\n\t\tconst { importers, dynamicImporters } = this;\n\t\tconst info: ModuleInfo = (this.info = {\n\t\t\tast: null,\n\t\t\tcode: null,\n\t\t\tdynamicallyImportedIdResolutions: EMPTY_ARRAY,\n\t\t\tdynamicallyImportedIds: EMPTY_ARRAY,\n\t\t\tget dynamicImporters() {\n\t\t\t\treturn dynamicImporters.sort();\n\t\t\t},\n\t\t\thasDefaultExport: null,\n\t\t\tget hasModuleSideEffects() {\n\t\t\t\twarnDeprecation(\n\t\t\t\t\t'Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.',\n\t\t\t\t\tfalse,\n\t\t\t\t\toptions\n\t\t\t\t);\n\t\t\t\treturn info.moduleSideEffects;\n\t\t\t},\n\t\t\tid,\n\t\t\timplicitlyLoadedAfterOneOf: EMPTY_ARRAY,\n\t\t\timplicitlyLoadedBefore: EMPTY_ARRAY,\n\t\t\timportedIdResolutions: EMPTY_ARRAY,\n\t\t\timportedIds: EMPTY_ARRAY,\n\t\t\tget importers() {\n\t\t\t\treturn importers.sort();\n\t\t\t},\n\t\t\tisEntry: false,\n\t\t\tisExternal: true,\n\t\t\tisIncluded: null,\n\t\t\tmeta,\n\t\t\tmoduleSideEffects,\n\t\t\tsyntheticNamedExports: false\n\t\t});\n\t\t// Hide the deprecated key so that it only warns when accessed explicitly\n\t\tObject.defineProperty(this.info, 'hasModuleSideEffects', {\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tgetVariableForExportName(name: string): [variable: ExternalVariable] {\n\t\tconst declaration = this.declarations.get(name);\n\t\tif (declaration) return [declaration];\n\t\tconst externalVariable = new ExternalVariable(this, name);\n\n\t\tthis.declarations.set(name, externalVariable);\n\t\tthis.exportedVariables.set(externalVariable, name);\n\t\treturn [externalVariable];\n\t}\n\n\tsetRenderPath(options: NormalizedOutputOptions, inputBase: string): void {\n\t\tthis.renderPath =\n\t\t\ttypeof options.paths === 'function' ? options.paths(this.id) : options.paths[this.id];\n\t\tif (!this.renderPath) {\n\t\t\tthis.renderPath = this.renormalizeRenderPath\n\t\t\t\t? normalize(relative(inputBase, this.id))\n\t\t\t\t: this.id;\n\t\t}\n\t}\n\n\tsuggestName(name: string): void {\n\t\tconst value = (this.nameSuggestions.get(name) ?? 0) + 1;\n\t\tthis.nameSuggestions.set(name, value);\n\n\t\tif (value > this.mostCommonSuggestion) {\n\t\t\tthis.mostCommonSuggestion = value;\n\t\t\tthis.suggestedVariableName = name;\n\t\t}\n\t}\n\n\twarnUnusedImports(): void {\n\t\tconst unused = Array.from(this.declarations)\n\t\t\t.filter(\n\t\t\t\t([name, declaration]) =>\n\t\t\t\t\tname !== '*' && !declaration.included && !this.reexported && !declaration.referenced\n\t\t\t)\n\t\t\t.map(([name]) => name);\n\n\t\tif (unused.length === 0) return;\n\n\t\tconst importersSet = new Set<string>();\n\t\tfor (const name of unused) {\n\t\t\tfor (const importer of this.declarations.get(name)!.module.importers) {\n\t\t\t\timportersSet.add(importer);\n\t\t\t}\n\t\t}\n\t\tconst importersArray = [...importersSet];\n\t\tthis.options.onwarn({\n\t\t\tcode: 'UNUSED_EXTERNAL_IMPORT',\n\t\t\tmessage: `${printQuotedStringList(unused, ['is', 'are'])} imported from external module \"${\n\t\t\t\tthis.id\n\t\t\t}\" but never used in ${printQuotedStringList(\n\t\t\t\timportersArray.map(importer => relativeId(importer))\n\t\t\t)}.`,\n\t\t\tnames: unused,\n\t\t\tsource: this.id,\n\t\t\tsources: importersArray\n\t\t});\n\t}\n}\n","import { extname, win32, posix, isAbsolute, resolve } from 'path';\nimport pm from 'picomatch';\n\nconst addExtension = function addExtension(filename, ext = '.js') {\n    let result = `${filename}`;\n    if (!extname(filename))\n        result += ext;\n    return result;\n};\n\nclass WalkerBase {constructor() { WalkerBase.prototype.__init.call(this);WalkerBase.prototype.__init2.call(this);WalkerBase.prototype.__init3.call(this);WalkerBase.prototype.__init4.call(this); }\n\t __init() {this.should_skip = false;}\n\t __init2() {this.should_remove = false;}\n\t __init3() {this.replacement = null;}\n\n\t __init4() {this.context = {\n\t\tskip: () => (this.should_skip = true),\n\t\tremove: () => (this.should_remove = true),\n\t\treplace: (node) => (this.replacement = node)\n\t};}\n\n\t replace(parent, prop, index, node) {\n\t\tif (parent) {\n\t\t\tif (index !== null) {\n\t\t\t\tparent[prop][index] = node;\n\t\t\t} else {\n\t\t\t\tparent[prop] = node;\n\t\t\t}\n\t\t}\n\t}\n\n\t remove(parent, prop, index) {\n\t\tif (parent) {\n\t\t\tif (index !== null) {\n\t\t\t\tparent[prop].splice(index, 1);\n\t\t\t} else {\n\t\t\t\tdelete parent[prop];\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass SyncWalkerClass extends WalkerBase {\n\t\n\t\n\n\tconstructor(walker) {\n\t\tsuper();\n\t\tthis.enter = walker.enter;\n\t\tthis.leave = walker.leave;\n\t}\n\n\t visit(\n\t\tnode,\n\t\tparent,\n\t\tenter,\n\t\tleave,\n\t\tprop,\n\t\tindex\n\t) {\n\t\tif (node) {\n\t\t\tif (enter) {\n\t\t\t\tconst _should_skip = this.should_skip;\n\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\tthis.should_skip = false;\n\t\t\t\tthis.should_remove = false;\n\t\t\t\tthis.replacement = null;\n\n\t\t\t\tenter.call(this.context, node, parent, prop, index);\n\n\t\t\t\tif (this.replacement) {\n\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (this.should_remove) {\n\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst skipped = this.should_skip;\n\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\tthis.should_skip = _should_skip;\n\t\t\t\tthis.should_remove = _should_remove;\n\t\t\t\tthis.replacement = _replacement;\n\n\t\t\t\tif (skipped) return node;\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\n\t\t\tfor (const key in node) {\n\t\t\t\tconst value = (node )[key];\n\n\t\t\t\tif (typeof value !== \"object\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t\tif (value[i] !== null && typeof value[i].type === 'string') {\n\t\t\t\t\t\t\tif (!this.visit(value[i], node, enter, leave, key, i)) {\n\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (value !== null && typeof value.type === \"string\") {\n\t\t\t\t\tthis.visit(value, node, enter, leave, key, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (leave) {\n\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\tthis.replacement = null;\n\t\t\t\tthis.should_remove = false;\n\n\t\t\t\tleave.call(this.context, node, parent, prop, index);\n\n\t\t\t\tif (this.replacement) {\n\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (this.should_remove) {\n\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\tthis.replacement = _replacement;\n\t\t\t\tthis.should_remove = _should_remove;\n\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n}\n\nfunction walk(ast, walker) {\n\tconst instance = new SyncWalkerClass(walker);\n\treturn instance.visit(ast, null, walker.enter, walker.leave);\n}\n\nconst extractors = {\n    ArrayPattern(names, param) {\n        for (const element of param.elements) {\n            if (element)\n                extractors[element.type](names, element);\n        }\n    },\n    AssignmentPattern(names, param) {\n        extractors[param.left.type](names, param.left);\n    },\n    Identifier(names, param) {\n        names.push(param.name);\n    },\n    MemberExpression() { },\n    ObjectPattern(names, param) {\n        for (const prop of param.properties) {\n            // @ts-ignore Typescript reports that this is not a valid type\n            if (prop.type === 'RestElement') {\n                extractors.RestElement(names, prop);\n            }\n            else {\n                extractors[prop.value.type](names, prop.value);\n            }\n        }\n    },\n    RestElement(names, param) {\n        extractors[param.argument.type](names, param.argument);\n    }\n};\nconst extractAssignedNames = function extractAssignedNames(param) {\n    const names = [];\n    extractors[param.type](names, param);\n    return names;\n};\n\nconst blockDeclarations = {\n    const: true,\n    let: true\n};\nclass Scope {\n    constructor(options = {}) {\n        this.parent = options.parent;\n        this.isBlockScope = !!options.block;\n        this.declarations = Object.create(null);\n        if (options.params) {\n            options.params.forEach((param) => {\n                extractAssignedNames(param).forEach((name) => {\n                    this.declarations[name] = true;\n                });\n            });\n        }\n    }\n    addDeclaration(node, isBlockDeclaration, isVar) {\n        if (!isBlockDeclaration && this.isBlockScope) {\n            // it's a `var` or function node, and this\n            // is a block scope, so we need to go up\n            this.parent.addDeclaration(node, isBlockDeclaration, isVar);\n        }\n        else if (node.id) {\n            extractAssignedNames(node.id).forEach((name) => {\n                this.declarations[name] = true;\n            });\n        }\n    }\n    contains(name) {\n        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);\n    }\n}\nconst attachScopes = function attachScopes(ast, propertyName = 'scope') {\n    let scope = new Scope();\n    walk(ast, {\n        enter(n, parent) {\n            const node = n;\n            // function foo () {...}\n            // class Foo {...}\n            if (/(Function|Class)Declaration/.test(node.type)) {\n                scope.addDeclaration(node, false, false);\n            }\n            // var foo = 1\n            if (node.type === 'VariableDeclaration') {\n                const { kind } = node;\n                const isBlockDeclaration = blockDeclarations[kind];\n                node.declarations.forEach((declaration) => {\n                    scope.addDeclaration(declaration, isBlockDeclaration, true);\n                });\n            }\n            let newScope;\n            // create new function scope\n            if (/Function/.test(node.type)) {\n                const func = node;\n                newScope = new Scope({\n                    parent: scope,\n                    block: false,\n                    params: func.params\n                });\n                // named function expressions - the name is considered\n                // part of the function's scope\n                if (func.type === 'FunctionExpression' && func.id) {\n                    newScope.addDeclaration(func, false, false);\n                }\n            }\n            // create new for scope\n            if (/For(In|Of)?Statement/.test(node.type)) {\n                newScope = new Scope({\n                    parent: scope,\n                    block: true\n                });\n            }\n            // create new block scope\n            if (node.type === 'BlockStatement' && !/Function/.test(parent.type)) {\n                newScope = new Scope({\n                    parent: scope,\n                    block: true\n                });\n            }\n            // catch clause has its own block scope\n            if (node.type === 'CatchClause') {\n                newScope = new Scope({\n                    parent: scope,\n                    params: node.param ? [node.param] : [],\n                    block: true\n                });\n            }\n            if (newScope) {\n                Object.defineProperty(node, propertyName, {\n                    value: newScope,\n                    configurable: true\n                });\n                scope = newScope;\n            }\n        },\n        leave(n) {\n            const node = n;\n            if (node[propertyName])\n                scope = scope.parent;\n        }\n    });\n    return scope;\n};\n\n// Helper since Typescript can't detect readonly arrays with Array.isArray\nfunction isArray